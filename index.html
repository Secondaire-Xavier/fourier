<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dessin par S√©ries de Fourier</title>
    <style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    padding: 10px;
    min-height: 100vh;
    overflow-x: hidden;
}

h1 {
    color: white;
    text-align: center;
    margin-bottom: 15px;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    font-size: 1.5rem;
}

.container {
    display: flex;
    flex-direction: column;
    gap: 15px;
    max-width: 100%;
    margin: 0 auto;
}

.sidebar {
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 100%;
}

.panel {
    background: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

.panel h3 {
    margin-bottom: 10px;
    color: #667eea;
    font-size: 14px;
    border-bottom: 2px solid #667eea;
    padding-bottom: 5px;
}

.control-group {
    display: flex;
    flex-direction: column;
    margin-bottom: 10px;
}

.label_span {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
}

label {
    font-size: 11px;
    font-weight: 600;
    color: #555;
}

input[type="number"] {
    padding: 6px;
    border: 2px solid #ddd;
    border-radius: 5px;
    font-size: 12px;
    width: 100%;
    margin-top: 5px;
}

input[type="range"] {
    padding: 6px 0;
    border-radius: 5px;
    font-size: 12px;
    width: 100%;
}

.value-display {
    font-size: 12px;
    color: #667eea;
    font-weight: bold;
    text-align: right;
}

button {
    padding: 8px 15px;
    background: #667eea;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: 600;
    transition: background 0.3s;
    width: 100%;
    margin-bottom: 8px;
    font-size: 12px;
}

button:hover {
    background: #5568d3;
}

button.secondary {
    background: #95a5a6;
}

button.secondary:hover {
    background: #7f8c8d;
}

button.danger {
    background: #e74c3c;
}

button.danger:hover {
    background: #c0392b;
}

.canvas-container {
    background: white;
    border-radius: 8px;
    box-shadow: 0 8px 16px rgba(0,0,0,0.2);
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 100%;
    max-height: 80vh;
}

.canvas-wrapper {
    position: relative;
    overflow: hidden;
    border: 2px solid #ddd;
    border-radius: 5px;
    width: 100%;
}

canvas {
    display: block;
    width: 100% !important;
    height: auto !important;
    touch-action: none;
}

canvas.drawing-mode {
    cursor: crosshair;
}

canvas.pan-mode {
    cursor: grab;
}

.canvas-controls {
    display: flex;
    gap: 8px;
    justify-content: center;
    flex-wrap: wrap;
}

.canvas-controls button {
    width: auto;
    padding: 6px 12px;
    font-size: 12px;
}

/* Media Queries pour desktop */
@media (min-width: 768px) {
    body {
        padding: 20px;
    }

    h1 {
        font-size: 2rem;
    }

    .container {
        flex-direction: row;
        gap: 20px;
        max-width: 1600px;
    }

    .sidebar {
        width: 300px;
    }

    .canvas-container {
        max-width: 80%;
        max-height: 120vh;
    }

    .panel {
        padding: 20px;
    }

    .panel h3 {
        font-size: 16px;
    }

    label {
        font-size: 12px;
    }

    input[type="number"], input[type="range"] {
        padding: 8px;
        font-size: 14px;
    }

    .value-display {
        font-size: 14px;
    }

    button {
        padding: 10px 20px;
        font-size: 14px;
    }

    .canvas-controls button {
        padding: 8px 16px;
        font-size: 14px;
    }
}
    </style>
</head>
<body>
    <h1>üé® Dessin par S√©ries de Fourier</h1>
    
    <div class="container">
        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Contr√¥les d'animation -->
            <div class="panel">
                <h3>‚öôÔ∏è Animation</h3>
                
                <div class="control-group">
                    <label>Nombre d'√©picycles</label>
                    <input type="number" id="nCoeffs" value="50" min="1" max="500">
                </div>
                
                <div class="control-group">
                    <div class = "label_span"><label>Vitesse</label><span class="value-display" id="speedValue">0.10</span></div>
                    <input type="range" id="speed" min="0.01" max="1.0" step="0.01" value="0.10">
                </div>
                
                <div class="control-group">
                    <div class = "label_span"><label>Longueur tra√Æn√©e</label><span class="value-display" id="trailValue">0.7</span></div>
                    <input type="range" id="trail" min="0.05" max="1.0" step="0.05" value="0.7">
                </div>
                
                <button onclick="toggleAnimation()" id="playBtn">‚è∏Ô∏è Pause</button>
                <button onclick="resetAnimation()">üîÑ Reset</button>
                <button onclick="resetView()">üéØ Centrer</button>
            </div>
            
            <!-- Canvas Controls -->
            <div class="panel">
                <h3>üé® Dessin</h3>
                
                <div class="control-group">
                    <label>Nombre de points √† √©chantillonner</label>
                    <input type="number" id="samplePoints" value="200" min="50" max="1000" step="50">
                </div>
                
                <button onclick="startDrawing()" id="drawBtn">‚úèÔ∏è Dessiner</button>
                <button onclick="clearDrawing()" class="danger">üóëÔ∏è Effacer</button>
                <button onclick="applyDrawing()" class="secondary">‚úÖ Appliquer le dessin</button>
            </div>
        </div>
        
        <!-- Canvas principal -->
        <div class="canvas-container">
            <div class="canvas-wrapper">
                <canvas id="canvas" width="1000" height="700"></canvas>
            </div>
        </div>
    </div>

    <script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// √âtat
let animationRunning = true;
let drawingMode = false;
let time = 0;
let coeffs = [];
let fullPath = [];
let epicycleData = [];
let drawnPoints = [];
let isDrawing = false;

// Param√®tres
let nCoeffs = 50;
let speed = 0.10;
let trailLength = 0.7;
let nDrawPoints = 5000;
let nFrames = 500;
let samplePoints = 200;

// Zoom & Pan
let zoom = 1;
let offsetX = 0;
let offsetY = 0;
let isPanning = false;
let lastPanX = 0;
let lastPanY = 0;

// Ajuster la taille du canvas
function resizeCanvas() {
    const container = canvas.parentElement;
    const width = container.clientWidth;
    const height = Math.min(width * 0.7, window.innerHeight * 0.85);
    canvas.width = width;
    canvas.height = height;
}

// Appeler au chargement et au redimensionnement
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Event listeners pour les contr√¥les
document.getElementById('speed').addEventListener('input', (e) => {
    speed = parseFloat(e.target.value);
    document.getElementById('speedValue').textContent = speed.toFixed(2);
});

document.getElementById('trail').addEventListener('input', (e) => {
    trailLength = parseFloat(e.target.value);
    document.getElementById('trailValue').textContent = trailLength.toFixed(2);
});

document.getElementById('nCoeffs').addEventListener('change', (e) => {
    nCoeffs = parseInt(e.target.value);
    if (fullPath.length > 0) {
        resetAnimation();
    }
});

document.getElementById('samplePoints').addEventListener('change', (e) => {
    samplePoints = parseInt(e.target.value);
});

// Gestion des √©v√©nements souris
canvas.addEventListener('mousedown', handleMouseDown);
canvas.addEventListener('mousemove', handleMouseMove);
canvas.addEventListener('mouseup', handleMouseUp);
canvas.addEventListener('wheel', handleWheel);

// Gestion des √©v√©nements tactiles
canvas.addEventListener('touchstart', handleTouchStart);
canvas.addEventListener('touchmove', handleTouchMove);
canvas.addEventListener('touchend', handleTouchEnd);

function getEventPosition(e) {
    const rect = canvas.getBoundingClientRect();
    let clientX, clientY;
    if (e.type.startsWith('touch')) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    } else {
        clientX = e.clientX;
        clientY = e.clientY;
    }
    return {
        x: (clientX - rect.left - canvas.width / 2 - offsetX) / zoom,
        y: (clientY - rect.top - canvas.height / 2 - offsetY) / zoom,
        clientX,
        clientY
    };
}

function handleMouseDown(e) {
    const pos = getEventPosition(e);
    if (drawingMode) {
        isDrawing = true;
        drawnPoints = [[pos.x, pos.y]];
    } else if (e.shiftKey || e.button === 2) {
        isPanning = true;
        lastPanX = pos.clientX;
        lastPanY = pos.clientY;
        canvas.style.cursor = 'grabbing';
    }
}

function handleMouseMove(e) {
    const pos = getEventPosition(e);
    if (isDrawing && drawingMode) {
        drawnPoints.push([pos.x, pos.y]);
    } else if (isPanning) {
        offsetX += pos.clientX - lastPanX;
        offsetY += pos.clientY - lastPanY;
        lastPanX = pos.clientX;
        lastPanY = pos.clientY;
    }
}

function handleMouseUp(e) {
    isDrawing = false;
    isPanning = false;
    canvas.style.cursor = drawingMode ? 'crosshair' : 'grab';
}

function handleTouchStart(e) {
    e.preventDefault();
    const pos = getEventPosition(e);
    if (drawingMode) {
        isDrawing = true;
        drawnPoints = [[pos.x, pos.y]];
    } else {
        isPanning = true;
        lastPanX = pos.clientX;
        lastPanY = pos.clientY;
    }
}

function handleTouchMove(e) {
    e.preventDefault();
    const pos = getEventPosition(e);
    if (isDrawing && drawingMode) {
        drawnPoints.push([pos.x, pos.y]);
    } else if (isPanning) {
        offsetX += pos.clientX - lastPanX;
        offsetY += pos.clientY - lastPanY;
        lastPanX = pos.clientX;
        lastPanY = pos.clientY;
    }
}

function handleTouchEnd(e) {
    e.preventDefault();
    isDrawing = false;
    isPanning = false;
}

function handleWheel(e) {
    e.preventDefault();
    const delta = e.deltaY > 0 ? 0.9 : 1.1;
    zoom = Math.max(0.1, Math.min(3, zoom * delta));
}

function startDrawing() {
    drawingMode = true;
    animationRunning = false;
    drawnPoints = [];
    canvas.classList.add('drawing-mode');
    canvas.classList.remove('pan-mode');
}

function clearDrawing() {
    drawnPoints = [];
}

function applyDrawing() {
    if (drawnPoints.length < 10) {
        alert('Dessinez au moins 10 points !');
        return;
    }

    const resampled = resamplePoints(drawnPoints, samplePoints);
    drawingMode = false;
    canvas.classList.remove('drawing-mode');
    canvas.classList.add('pan-mode');
    initFourier(resampled);
    animationRunning = true;
    draw();
}

function resamplePoints(points, n) {
    if (points.length <= n) return points;
    const resampled = [];
    const step = points.length / n;
    for (let i = 0; i < n; i++) {
        const idx = Math.floor(i * step);
        resampled.push(points[idx]);
    }
    return resampled;
}

function resetView() {
    zoom = 1;
    offsetX = 0;
    offsetY = 0;
}

function baseShape() {
    const points = [];
    for (let i = 0; i < 200; i++) {
        const t = (i / 200) * 2 * Math.PI;
        const x = 16 * Math.pow(Math.sin(t), 3);
        const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
        points.push([x * 8, y * 8]);
    }
    initFourier(points);
    animationRunning = true;
}

function computeFourierCoefficients(points, n) {
    const N = points.length;
    const coeffsList = [];
    for (let freq = -Math.floor(n/2); freq <= Math.floor(n/2); freq++) {
        let real = 0, imag = 0;
        for (let i = 0; i < N; i++) {
            const t = i / N;
            const angle = -2 * Math.PI * freq * t;
            real += points[i][0] * Math.cos(angle) - points[i][1] * Math.sin(angle);
            imag += points[i][0] * Math.sin(angle) + points[i][1] * Math.cos(angle);
        }
        real /= N;
        imag /= N;
        const magnitude = Math.sqrt(real * real + imag * imag);
        const phase = Math.atan2(imag, real);
        coeffsList.push({ freq, real, imag, magnitude, phase });
    }
    coeffsList.sort((a, b) => b.magnitude - a.magnitude);
    return coeffsList.slice(0, n);
}

function precomputePath(coeffs, nPoints) {
    const path = [];
    for (let i = 0; i < nPoints; i++) {
        const t = i / nPoints;
        let x = 0, y = 0;
        for (const c of coeffs) {
            const angle = 2 * Math.PI * c.freq * t + c.phase;
            x += c.magnitude * Math.cos(angle);
            y += c.magnitude * Math.sin(angle);
        }
        path.push([x, y]);
    }
    return path;
}

function precomputeEpicycles(coeffs, nFrames) {
    const data = [];
    for (let i = 0; i < nFrames; i++) {
        const t = i / nFrames;
        const frame = [];
        let x = 0, y = 0;
        for (const c of coeffs) {
            const startX = x, startY = y;
            const angle = 2 * Math.PI * c.freq * t + c.phase;
            x += c.magnitude * Math.cos(angle);
            y += c.magnitude * Math.sin(angle);
            frame.push({ startX, startY, endX: x, endY: y, radius: c.magnitude });
        }
        data.push(frame);
    }
    return data;
}

function initFourier(points) {
    coeffs = computeFourierCoefficients(points, nCoeffs);
    fullPath = precomputePath(coeffs, nDrawPoints);
    epicycleData = precomputeEpicycles(coeffs, nFrames);
    time = 0;
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(canvas.width / 2 + offsetX, canvas.height / 2 + offsetY);
    ctx.scale(zoom, zoom);

    if (drawingMode) {
        if (drawnPoints.length > 1) {
            ctx.beginPath();
            ctx.moveTo(drawnPoints[0][0], drawnPoints[0][1]);
            for (let i = 1; i < drawnPoints.length; i++) {
                ctx.lineTo(drawnPoints[i][0], drawnPoints[i][1]);
            }
            ctx.strokeStyle = 'rgba(102, 126, 234, 0.8)';
            ctx.lineWidth = 3 / zoom;
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(drawnPoints[0][0], drawnPoints[0][1], 5 / zoom, 0, 2 * Math.PI);
            ctx.fillStyle = 'green';
            ctx.fill();
        }
    } else if (animationRunning && epicycleData.length > 0) {
        const epicycleIdx = Math.floor(time * nFrames) % nFrames;
        const pathIdx = Math.floor(time * nDrawPoints) % nDrawPoints;
        const frameData = epicycleData[epicycleIdx];

        for (const ep of frameData) {
            ctx.beginPath();
            ctx.arc(ep.startX, ep.startY, ep.radius, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(150, 150, 150, 0.3)';
            ctx.lineWidth = 1 / zoom;
            ctx.stroke();
        }

        ctx.beginPath();
        ctx.moveTo(frameData[0].startX, frameData[0].startY);
        for (const ep of frameData) {
            ctx.lineTo(ep.endX, ep.endY);
        }
        ctx.strokeStyle = 'rgba(100, 150, 255, 0.6)';
        ctx.lineWidth = 2 / zoom;
        ctx.stroke();

        for (const ep of frameData) {
            ctx.beginPath();
            ctx.arc(ep.endX, ep.endY, 3 / zoom, 0, 2 * Math.PI);
            ctx.fillStyle = 'red';
            ctx.fill();
        }

        const trailPoints = Math.floor(nDrawPoints * trailLength);
        ctx.beginPath();
        const startIdx = pathIdx - trailPoints;
        if (startIdx >= 0) {
            ctx.moveTo(fullPath[startIdx][0], fullPath[startIdx][1]);
            for (let i = startIdx + 1; i <= pathIdx; i++) {
                ctx.lineTo(fullPath[i][0], fullPath[i][1]);
            }
        } else {
            ctx.moveTo(fullPath[nDrawPoints + startIdx][0], fullPath[nDrawPoints + startIdx][1]);
            for (let i = nDrawPoints + startIdx + 1; i < nDrawPoints; i++) {
                ctx.lineTo(fullPath[i][0], fullPath[i][1]);
            }
            for (let i = 0; i <= pathIdx; i++) {
                ctx.lineTo(fullPath[i][0], fullPath[i][1]);
            }
        }

        ctx.strokeStyle = 'rgba(255, 50, 50, 0.8)';
        ctx.lineWidth = 2 / zoom;
        ctx.stroke();

        const finalX = frameData[frameData.length - 1].endX;
        const finalY = frameData[frameData.length - 1].endY;
        ctx.beginPath();
        ctx.arc(finalX, finalY, 5 / zoom, 0, 2 * Math.PI);
        ctx.fillStyle = 'red';
        ctx.fill();

        time = (time + speed/50) % 1.0;
    }

    ctx.restore();
    requestAnimationFrame(draw);
}

function toggleAnimation() {
    if (drawingMode) return;
    animationRunning = !animationRunning;
    const btn = document.getElementById('playBtn');
    btn.textContent = animationRunning ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
}

function resetAnimation() {
    time = 0;
    if (drawnPoints.length > 0) {
        const resampled = resamplePoints(drawnPoints, samplePoints);
        initFourier(resampled);
    } else {
        baseShape();
    }
}

// D√©marrage
canvas.classList.add('pan-mode');
baseShape();
draw();
    </script>
</body>
</html>
